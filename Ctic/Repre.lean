import Ctic.Limit

namespace CTIC

notation:max "Hom[" x ", " "-" "]" => HomCov xแตแต
notation:max "Hom[" x ", " y "]" => Functor.obj Hom[x, -] y
notation:max "Hom[" "-" ", " x "]" => HomCon x

notation:max "Hom[" F "(" "-" ")" ", " Y "]" => Fแตแต โ Hom[-, Y]
notation:max "Hom[" X ", " F "(" "-" ")" "]" => F โ Hom[X, -]

open Lean in
@[app_unexpander Functor.comp]
def unexpand_Functor_comp_HomCon : PrettyPrinter.Unexpander
  | `($(_) $fแตแต Hom[-, $y]) => `(Hom[$f(-), $y])
  | _ => throw ()

open Lean in
@[app_unexpander Functor.comp]
def unexpand_Functor_comp_HomCov : PrettyPrinter.Unexpander
  | `($(_) $f Hom[$x, -]) => `(Hom[$x, $f(-)])
  | _ => throw ()

open Lean in
@[app_unexpander Functor.obj]
def unexpand_Functor_comp_HomCon_obj : PrettyPrinter.Unexpander
  | `($(_) Hom[$f(-), $y] $xแตแต) => `(Hom[$f $x, $y])
  | `($(_) Hom[$f(-), $y] $x) =>
    match x with
    | `({ unop := $x }) => `(Hom[$f $x, $y])
    | _ => `(Hom[$f $xแตแต, $y])
  | _ => throw ()

open Lean in
@[app_unexpander Functor.obj]
def unexpand_Functor_HomCon_obj : PrettyPrinter.Unexpander
  | `($(_) Hom[-, $y] $xแตแต) => `(Hom[$x, $y])
  | `($(_) Hom[-, $y] $x) =>
    match x with
    | `({ unop := $x }) => `(Hom[$x, $y])
    | _ => `(Hom[$xแตแต, $y])
  | _ => throw ()

open Lean in
@[app_unexpander Functor.obj]
def unexpand_Functor_comp_HomCov_obj : PrettyPrinter.Unexpander
  | `($(_) Hom[$x, $f(-)] $y) => `(Hom[$x, $f $y])
  | _ => throw ()

open Lean in
@[app_unexpander Functor.obj]
def unexpand_Functor_HomCov_obj : PrettyPrinter.Unexpander
  | `($(_) Hom[$x, -] $y) => `(Hom[$x, $y])
  | _ => throw ()

@[simp]
theorem HomCon.comp_obj_def [Category C] [Category D] {F : C โฅค D} {X : C} {Y : D} :
    Hom[F(-), Y] { unop := X } = Hom[F X, Y] := by rfl

@[simp]
theorem HomCon.comp_obj_def' [Category C] [Category D] {F : C โฅค D} {X : C} {Y : D} :
    Hom[F(-), Y] Xแตแต = Hom[F X, Y] := by rfl

@[simp]
theorem Functor.op_map_def [Category C] [Category D] {F : C โฅค D} {X : C} {Y : C} {f : X โถ Y} :
    Fแตแต.map f = F.map f := by rfl

theorem NatTrans.naturality_expanded_set_valued
    [Category C] {F G : C โฅค Type v} {ฮฑ : F โน G} {X Y : C} (f : X โถ Y) :
    โ u, G.map f (ฮฑ.component X u) = ฮฑ.component Y (F.map f u) := by
  rw [โ funext_iff]
  rw [โ Function.comp_def]
  rw [โ Function.comp_def]
  exact ฮฑ.naturality f

namespace Yoneda

namespace Covariant

abbrev t1 [Category.{u, v + 1} C] (F : C โฅค Type v) (x : C) : (Hom[x, -] โน F) โ (F x) :=
  fun ฮท => ฮท.component x (๐ x)

abbrev t2 [Category.{u, v + 1} C] (F : C โฅค Type v) (x : C) : (F x) โ (Hom[x, -] โน F) := by
  intro Fx
  letI t (y : C) : Hom[x, y] โถ F y := fun f => by
    exact F.map f Fx
  use t
  intro X Y f
  simp [t]
  simp [Category.comp]
  funext u
  simp [t]
  simp [Category.comp]

def iso [Category.{u} C] (F : C โฅค Type u) (x : C) : (Hom[x, -] โน F) โ (F x) where
  morphism := t1 F x
  inverse := t2 F x
  forward := by
    simp [Category.comp]
    funext ฮฑ
    simp [t2, t1]
    ext v
    congr
    ext y f
    clear v
    simp [HomCov] at f
    have := ฮฑ.naturality_expanded_set_valued f (๐ x)
    simp [HomCov] at this
    exact this
  backward := by
    simp [Category.comp]
    funext Y
    simp [t1, t2]

def yoneda_factor_x [Category.{u} C] (F : C โฅค Type u) : C โฅค Type u where
  obj x := Hom[x, -] โน F
  map {X Y} f := by
    simp
    intro T
    let t : (Z : C) โ Hom[Y, Z] โถ F.obj Z := by
      intro Z g
      apply T.component
      exact (f โซ g)
    use t
    intro U V g
    simp [t]
    simp [Category.comp]
    simp [HomCov]
    funext s
    simp
    exact T.naturality_expanded_set_valued g (f โซ s)
  map_id := by
    intro X
    simp [Category.id]
    funext t
    simp
  map_comp := by
    intro X Y Z f g
    simp [Category.comp]
    funext t
    simp

def natural_in_x [Category.{u} C] (F : C โฅค Type u) : yoneda_factor_x F โ F where
  morphism := by
    use fun x => (iso F x).morphism
    intro X Y f
    simp [Category.comp]
    funext t
    simp
    simp [iso, t1, yoneda_factor_x]
    have := t.naturality_expanded_set_valued f
    simp [HomCov, Category.comp] at this
    simp [this]
  inverse := by
    use fun x => (iso F x).inverse
    intro X Y f
    simp [Category.comp]
    funext t
    simp
    simp [iso, t1, yoneda_factor_x]
    simp [Category.comp]
  forward := by
    simp [Category.id, NatTrans.id]
    simp [Category.comp, NatTrans.comp]
    congr
    funext X t
    simp [iso, t2, t1]
    congr
    funext c f
    have := t.naturality_expanded_set_valued f
    simp [HomCov, Category.comp] at this
    simp [this]
  backward := by
    simp [Category.id, NatTrans.id]
    simp [Category.comp, NatTrans.comp]
    congr
    funext X FX
    simp
    simp [iso, t2, t1]
    simp [Category.id]

def factor_F [Category.{v, v + 1} C] (c : C) : (C โฅค Type v) โฅค Type v where
  obj F := Hom[c, -] โน F
  map {G H} ฮฑ := by
    intro F
    constructor
    case component =>
      intro X h
      let t := F.component X h
      exact ฮฑ.component X t
    case naturality =>
      intro X Y f
      simp
      funext h
      simp [Category.comp]
      have := ฮฑ.naturality_expanded_set_valued f (F.component X h)
      rw [this]
      have := F.naturality_expanded_set_valued f h
      rw [this]

def functor_app_factor_func [Category.{v, v + 1} C] (c : C) : (C โฅค Type v) โฅค Type v where
  obj F := F.obj c
  map {G H} ฮฑ := by
    intro o
    exact ฮฑ.component _ o

def natural_in_F [Category.{v, v + 1} C] (c : C) : factor_F c โ functor_app_factor_func c where
  morphism := by
    simp [factor_F, functor_app_factor_func]
    constructor
    case component =>
      simp
      intro F ฮท
      exact ฮท.component _ (๐ c)
    case naturality =>
      simp
      intro X Y f
      funext ฮท
      simp [Category.comp]
  inverse := by
    simp [factor_F, functor_app_factor_func]
    constructor
    case component =>
      simp
      intro F o
      constructor
      case component =>
        intro Y f
        exact F.map f o
      case naturality =>
        intro X Y f
        simp [Category.comp, HomCov]
        funext g
        simp [Category.comp]
    case naturality =>
      intro F G ฮท
      simp [Category.comp]
      funext t
      simp
      funext u f
      have := ฮท.naturality_expanded_set_valued f
      simp at this
      rw [this]
  forward := by
    simp [Category.comp, NatTrans.comp]
    rw [NatTrans.ext_iff]
    funext t
    simp [Category.id]
    funext ฮท
    simp
    rw [NatTrans.ext_iff]
    simp
    funext Y f
    have := ฮท.naturality_expanded_set_valued f (๐ c)
    simp [this, HomCov]
  backward := by
    simp [Category.comp, NatTrans.comp]
    rw [NatTrans.ext_iff]
    funext t
    simp [Category.id]
    funext ฮท
    simp [Category.id]

def Embedding (C : Type u) [Category.{u} C] : Cแตแต โฅค (C โฅค Type u) where
  obj X := Hom[X.unop, -]
  map {X Y} f := by
    simp [Category.Hom]
    let t : (c : C) โ (Hom[X.unop, c] โ Hom[Y.unop, c]) := by
      intro c
      simp [HomCov]
      intro h
      let f' : Y.unop โถ X.unop := f
      exact f' โซ h
    use t
    intro U V g
    simp [HomCov, Category.comp]
    funext x
    simp [t]
  map_id := by
    intro X
    simp [Category.id, NatTrans.id]
    congr
  map_comp := by
    intro X Y Z f g
    simp [Category.comp, NatTrans.comp]
    congr
    funext _ _
    simp

def Faithful [Category.{u} C] : (Embedding C).Faithful := by
  intro X Y f g h1
  simp [Embedding] at h1
  rw [NatTrans.ext_iff] at h1
  simp at h1
  rw [funext_iff] at h1
  conv at h1 =>
    intro x
    rw [funext_iff]
    intro h
  specialize h1 (X.unop) (๐ X.unop)
  simp at h1
  exact h1

def Full [Category.{u} C] : (Embedding C).Full := by
  intro โจXโฉ โจYโฉ
  simp [Embedding]
  intro g
  simp [Category.Hom]
  conv =>
    rhs
    intro a
    rw [NatTrans.ext_iff]
    simp
  let f1 := iso (Hom[Y, -]) X
  let f2 := f1.morphism g
  use f2
  simp [f2, f1]
  simp [iso, t1]
  funext c h
  have := g.naturality_expanded_set_valued h (๐ X)
  simp [HomCov] at this
  exact this

def FullyFaithful [Category.{u} C] : (Embedding C).FullyFaithful := โจFull, Faithfulโฉ

end Covariant

namespace Contravariant

abbrev t1 [Category.{u, v + 1} C] (F : Cแตแต โฅค Type v) (x : C) : (Hom[-, x] โน F) โ (F xแตแต) :=
  fun ฮท => ฮท.component xแตแต (๐ x)

abbrev t2 [Category.{u, v + 1} C] (F : Cแตแต โฅค Type v) (y : C) : (F yแตแต) โ (Hom[-, y] โน F) := by
  intro Fx
  letI t (x : Cแตแต) : Hom[xแตแต, y] โถ F x := fun f => by
    exact F.map f Fx
  use t
  intro X Y f
  simp [t]
  simp [Category.comp]
  funext u
  simp [t]
  simp [HasOpposite.op]
  change yแตแต โถ X at u
  change F.map f (F.map u Fx) = F.map (u โซ f) Fx
  rw [Functor.map_comp]
  simp [Category.comp]

def iso [Category.{u} C] (F : Cแตแต โฅค Type u) (x : C) : (Hom[-, x] โน F) โ (F xแตแต) where
  morphism := t1 F x
  inverse := t2 F x
  forward := by
    simp [Category.comp]
    funext ฮฑ
    simp [t1, t2]
    ext v
    congr
    ext y f
    clear v
    simp [HomCov] at f
    have := ฮฑ.naturality_expanded_set_valued f (๐ x)
    simp [HomCov] at this
    exact this
  backward := by
    simp [Category.comp]
    funext Y
    simp [t1, t2]
    change F.map (๐ xแตแต) Y = (๐ F xแตแต) Y
    rw [Functor.map_id]

def Embedding (C : Type u) [Category.{u} C] : C โฅค (Cแตแต โฅค Type u) where
  obj X := Hom[-, X]
  map {X Y} f := by
    simp [Category.Hom]
    let t : (c : Cแตแต) โ (Hom[c.unop, X] โ Hom[c.unop, Y]) := by
      intro c
      simp [HomCov]
      intro h
      exact h โซ f
    use t
    intro U V g
    simp [HomCov, Category.comp]
    funext x
    simp [t]

def Faithful [Category.{u} C] : (Embedding C).Faithful := by
  intro X Y f g h1
  simp [Embedding] at h1
  rw [NatTrans.ext_iff] at h1
  simp at h1
  rw [funext_iff] at h1
  conv at h1 =>
    intro x
    rw [funext_iff]
    intro h
  specialize h1 (Xแตแต) (๐ Xแตแต)
  simp at h1
  exact h1

def Full [Category.{u} C] : (Embedding C).Full := by
  intro X Y
  simp [Embedding]
  intro g
  simp [Category.Hom]
  conv =>
    rhs
    intro a
    rw [NatTrans.ext_iff]
    simp
  let f1 := iso (Hom[-, Y]) X
  let f2 := f1.morphism g
  use f2
  simp [f2, f1]
  simp [iso, t1]
  funext c h
  have := g.naturality_expanded_set_valued h (๐ X)
  simp [HomCov] at this
  exact this

def FullyFaithful [Category.{u} C] : (Embedding C).FullyFaithful := โจFull, Faithfulโฉ

end Contravariant

end Yoneda

structure RepresentationCov [Category.{u} C] (F : C โฅค Type u) where
  obj : C
  iso : HomCov objแตแต โ F

structure RepresentationContra [Category.{u} C] (F : Cแตแต โฅค Type u) where
  obj : C
  iso : HomCon obj โ F

class inductive RepresentableCov [Category.{u} C] (F : C โฅค Type u) : Prop where
  | intro (rep : Nonempty (RepresentationCov F))

class inductive RepresentableContra [Category.{u} C] (F : Cแตแต โฅค Type u) : Prop where
  | intro (rep : Nonempty (RepresentationContra F))

variable {C : Type u}
variable [Category.{u} C]
variable {F : Cแตแต โฅค Type u}

abbrev CategoryOfElements (F : Cแตแต โฅค Type u) :=  Comma (Yoneda.Contravariant.Embedding C) (TrivialFunctor F)

prefix:max "โซ " => CategoryOfElements

lemma Yoneda.isic_of_terminal_in_category_of_elements
    [decEq : โ X, DecidableEq (F X)] {L : CategoryOfElements F} (terminal : Terminal L) : Invertible L.f := by
  obtain โจc, u, ฮฑโฉ := L
  change Hom[-, c] โถ F at ฮฑ
  apply NatTrans.isic_of_components_isic
  intro X
  simp
  apply Invertible.of_monic_and_epic_of_sets
  . rw [Function.Monic_iff_Injective]
    intro f g h1
    change Xแตแต โถ c at f g
    let s : CategoryOfElements F := โจXแตแต, (), Yoneda.Contravariant.iso F Xแตแต |>.inverse ((ฮฑ.component X) f)โฉ
    let t : CategoryOfElements F := โจXแตแต, (), Yoneda.Contravariant.iso F Xแตแต |>.inverse ((ฮฑ.component X) g)โฉ
    let p := terminal.morphism s
    let q := terminal.morphism t
    have h2 : s = t := by simp [s, t]; rw [h1]
    have h3 : p.k = q.k := by
      simp [p, q]
      congr
    have h5 : ((Yoneda.Contravariant.Embedding C).map f โซ ฮฑ) = (Yoneda.Contravariant.iso F Xแตแต).inverse (ฮฑ.component X f) := by
      have := (Yoneda.Contravariant.iso F Xแตแต).monic
      rw [Function.Monic_iff_Injective] at this
      apply this
      rw [โ Function.comp_apply (f := (Yoneda.Contravariant.iso F Xแตแต).morphism)]
      rw [โ Function.comp_apply (f := (Yoneda.Contravariant.iso F Xแตแต).morphism)]
      have : (Yoneda.Contravariant.iso F Xแตแต).morphism โ (Yoneda.Contravariant.iso F Xแตแต).inverse = ๐ (F X) := by
        funext t
        change F.map (๐ X) t = (๐ F X) t
        rw [Functor.map_id]
      rw [this]
      simp [Category.id, Yoneda.Contravariant.iso, Yoneda.Contravariant.Embedding, Yoneda.Contravariant.t1, Category.comp]
      change (ฮฑ.component X) (๐ X โซ f) = (ฮฑ.component X) f
      simp
    have h6 := p.commu
    change s.f = (Yoneda.Contravariant.Embedding C).map p.k โซ ฮฑ at h6
    have h7 := terminal.unique (X := s) (f := โจf, (), h5.symmโฉ)
    have h8 : f = p.k := by
      rw [CommaHom.ext_iff] at h7
      simp at h7
      simp [h7]
    have h10 : ((Yoneda.Contravariant.Embedding C).map g โซ ฮฑ) = (Yoneda.Contravariant.iso F Xแตแต).inverse (ฮฑ.component X g) := by
      have := (Yoneda.Contravariant.iso F Xแตแต).monic
      rw [Function.Monic_iff_Injective] at this
      apply this
      rw [โ Function.comp_apply (f := (Yoneda.Contravariant.iso F Xแตแต).morphism)]
      rw [โ Function.comp_apply (f := (Yoneda.Contravariant.iso F Xแตแต).morphism)]
      have : (Yoneda.Contravariant.iso F Xแตแต).morphism โ (Yoneda.Contravariant.iso F Xแตแต).inverse = ๐ (F X) := by
        funext t
        change F.map (๐ X) t = (๐ F X) t
        rw [Functor.map_id]
      rw [this]
      simp [Category.id, Yoneda.Contravariant.iso, Yoneda.Contravariant.Embedding, Yoneda.Contravariant.t1, Category.comp]
      change (ฮฑ.component X) (๐ X โซ g) = (ฮฑ.component X) g
      simp
    have h11 := q.commu
    change t.f = (Yoneda.Contravariant.Embedding C).map q.k โซ ฮฑ at h11
    have h12 := terminal.unique (X := t) (f := โจg, (), h10.symmโฉ)
    have h13 : g = q.k := by
      rw [CommaHom.ext_iff] at h12
      simp at h12
      simp [h12]
    rw [h8, h13]
    exact h3
  . rw [Function.Epic_iff_Surjective]
    intro e
    change F X at e
    let s : CategoryOfElements F := โจXแตแต, (), Yoneda.Contravariant.iso F Xแตแต |>.inverse eโฉ
    have h1 : s.f.component X (๐ X) = e := by
      simp [s, Yoneda.Contravariant.iso]
      change (F.map (๐ X)) e = e
      rw [Functor.map_id (X := X)]
      simp [Category.id]
    let t := terminal.morphism s
    have h2 := t.commu
    change s.f = (Yoneda.Contravariant.Embedding C).map t.k โซ ฮฑ at h2
    have h3 : (ฮฑ.component X) t.k = s.f.component X (๐ X) := by
      rw [h2]
      simp [Yoneda.Contravariant.Embedding]
      simp [Category.comp]
    have h4 := Eq.trans h3 h1
    use t.k

theorem Yoneda.terminal_in_category_of_elements_of_isic {L : CategoryOfElements F} (isic : Invertible L.f) : Nonempty (Terminal L) := by
  refine Nonempty.intro โจ?morphism, ?uniqueโฉ
  case morphism =>
    intro X
    let t : Hom[-, X.d] โถ Hom[-, L.d] := X.f โซ isic.choose
    use (Yoneda.Contravariant.FullyFaithful (C := C)).inv t, ()
    simp [t]
    have := isic.choose_spec
    rw [โ Category.assoc]
    rw [this.2]
    simp
  case unique =>
    intro X f
    obtain โจk, h, commuโฉ := f
    simp at commu
    simp
    congr
    apply (Yoneda.Contravariant.FullyFaithful (C := C)).right
    rw [(Yoneda.Contravariant.FullyFaithful (C := C)).map_inv]
    rw [commu]
    rw [โ Category.assoc]
    rw [isic.choose_spec.1]
    simp

theorem Yoneda.isic_iff_terminal_in_category_of_elements
    [โ X, DecidableEq (F X)] (L : CategoryOfElements F) : Nonempty (Terminal L) โ Invertible L.f :=
  โจfun โจneโฉ => Yoneda.isic_of_terminal_in_category_of_elements ne, Yoneda.terminal_in_category_of_elements_of_isicโฉ
